#!/usr/bin/env python
# -*- Mode: Python -*-

import argparse
import csv
import os
import sys


header_template = """-- -----------------------------------------------------------------
-- Create the service registry entry for %s
--
-- Execute as:
--
--    psql -U portal -h localhost -f add-%s.sql portal
--
-- -----------------------------------------------------------------
"""

agg_template = """
insert into service_registry
    (service_type, service_url, service_cert, service_name,
     service_description, service_urn)
  values
    ( -- TYPE: zero = aggregate
      0,
      -- URL
      '%s',
      -- CERT
     '@srcertsdir@/%s',
      -- NAME
     '%s',
      -- DESCRIPTION
     '%s',
      -- URN
     '%s'
    );
"""

ca_template = """
insert into service_registry
    (service_type, service_url, service_cert, service_name,
     service_description, service_urn)
  values
    ( -- TYPE: 7 = CA
      7,
      -- URL
     '',
      -- CERT (self signed)
     '@srcertsdir@/%s',
      -- NAME
     '',
      -- DESCRIPTION
     '%s',
      -- URN
     ''
    );
"""

type_template = """
-- Add service AM type
insert into service_registry_attribute
    (service_id, name, value)
  values
    (
      (select id from service_registry
        where service_urn
          = '%s'),
      'UI_AM_TYPE',
      '%s'
    );
"""

category_template = """
-- Add service AM categories
insert into service_registry_attribute
    (service_id, name, value)
  values
    (
     (select id from service_registry
       where service_urn
         = '%s'),
     'UI_AM_CAT',
     '%s'
    );
"""

class Aggregate(object):
    def __init__(self, values):
        self.shortname = values['shortname']
        self.longname = values['longname']
        self.description = values['description']
        self.url = values['url']
        self.urn = values['urn']
        self.amcert = values['amcert']
        self.cacert = values['cacert']
        self.amtype = values['type']
        self.category = values['category']
        self.speaksfor = values['speaksfor']

    def emit(self, out):
        self.emit_header(out)
        self.emit_agg_sql(out)
        self.emit_ca_sql(out)
        self.emit_type_sql(out)
        self.emit_category_sql(out)
        self.emit_speaksfor_sql(out)

    def emit_header(self, out):
        out.write(header_template % (self.longname, self.shortname))

    def emit_agg_sql(self, out):
        sql = agg_template % (self.url, self.amcert, self.longname,
                              self.description, self.urn)
        out.write(sql)

    def emit_ca_sql(self, out):
        ca_desc = '%s CA' % (self.longname)
        sql = ca_template % (self.cacert, ca_desc)
        out.write(sql)

    def emit_type_sql(self, out):
        sql = type_template % (self.urn, self.amtype)
        out.write(sql)

    def emit_category_sql(self, out):
        sql = category_template % (self.urn, self.category)
        out.write(sql)

    def emit_speaksfor_sql(self, out):
        pass


def parse_args(argv):
    parser = argparse.ArgumentParser(description='Process some integers.')
    # parser.add_argument('integers', metavar='N', type=int, nargs='+',
    #                    help='an integer for the accumulator')
    # parser.add_argument('--sum', dest='accumulate', action='store_const',
    #                    const=sum, default=max,
    #                    help='sum the integers (default: find the max)')
    parser.add_argument('infile', metavar='CSV_FILE',
                        help='A CSV file of aggregate data')
    parser.add_argument('-o', '--outdir', default='.',
                       help='output directory')

    args = parser.parse_args(argv)
    return args

def create_outdir(directory):
    # dir exists OR mkdir
    if not os.path.isdir(directory):
        os.makedirs(directory)

def generate(infile, outdir):
    with open(infile, 'rU') as csvfile:
        aggreader = csv.DictReader(csvfile)
        for row in aggreader:
            agg = Aggregate(row)
            fname = "%s/add-%s.sql.in" % (outdir, agg.shortname)
            with open(fname, 'wb') as aggfile:
                agg.emit(aggfile)

def main(argv=None):
    args = parse_args(argv)
    print "%r" % (args)
    print args.infile
    print args.outdir
    create_outdir(args.outdir)
    generate(args.infile, args.outdir)

if __name__ == "__main__":
    sys.exit(main())
